# Прикладное использование — рецепты с копипастой

Этот файл — практические инструкции «что делать руками» для трёх задач: риски, сенсоры, A/B-тесты. Здесь минимум терминов и максимум конкретики с работающими примерами.

## Установка и настройка

**Шаг 1. Установите библиотеку:**
```bash
# В корне проекта ProbStates
python3 -m venv .venv
source .venv/bin/activate   # Windows: .venv\Scripts\activate
pip install -e .
pip install matplotlib
```

**Шаг 2. Импорты для всех примеров:**
```python
import numpy as np
from probstates import ProbabilisticBit, PhaseState, PhaseRegister, set_phase_or_mode
from probstates.coherence import dephase, amp_damp
from probstates.entropy import shannon_entropy, kl_divergence, calculate_entropy
```
---

## Кейс 1: Управление рисками

**Задача:** Объединить несколько источников риска в общую оценку, учитывая что некоторые дублируют друг друга, а некоторые компенсируют.

### Рецепт (копируйте целиком):

```python
# БЛОК 1: Базовая оценка (простое сложение)
risk_sources = [0.12, 0.08, 0.18, 0.15]  # ваши вероятности рисков
print("Исходные риски:", risk_sources)

# Простое сложение на уровне 2
base_risk = ProbabilisticBit(risk_sources[0])
for p in risk_sources[1:]:
    base_risk = base_risk | ProbabilisticBit(p)
print("Базовый риск (простое сложение):", round(base_risk.probability, 4))

# БЛОК 2: Умное объединение с учётом дублей/конфликтов
# Настройте углы: 0 = вместе (дубли), π = вразнобой (компенсация)
angles = [0.0, 0.0, np.pi, np.pi/3]  # первые два дублируют, третий компенсирует
states = [PhaseState(p, angle) for p, angle in zip(risk_sources, angles)]

# Выберите режим склейки (попробуйте разные)
set_phase_or_mode('weight')  # робастный режим для продакшена
# set_phase_or_mode('norm')  # консервативный для регуляторики
# set_phase_or_mode('quant') # агрессивный для исследований

smart_risk = states[0]
for state in states[1:]:
    smart_risk = smart_risk | state

print("Умный риск (с учётом дублей):", round(smart_risk.probability, 4))

# БЛОК 3: Проверка на устойчивость к шумам
noisy_risk = smart_risk
noisy_risk = dephase(noisy_risk, sigma_phi=0.1)   # фазовый шум
noisy_risk = amp_damp(noisy_risk, alpha=0.2)      # затухание
print("Риск под шумом:", round(noisy_risk.probability, 4))

# БЛОК 4: Диагностика информативности
from probstates.entropy import calculate_entropy
h_base = calculate_entropy(base_risk)
h_smart = calculate_entropy(smart_risk)
print("Энтропия базового риска:", round(h_base, 3))
print("Энтропия умного риска:", round(h_smart, 3))
```

**Что менять под вашу задачу:**
- `risk_sources` — ваши вероятности рисков
- `angles` — пометьте дубли как `0.0`, компенсирующие как `np.pi`
- Режим склейки: `'weight'` (дефолт), `'norm'` (консервативно), `'quant'` (агрессивно)
---

## Кейс 2: Объединение датчиков

**Задача:** Слить показания нескольких датчиков, учитывая их калибровку, шумы и надёжность.

### Рецепт (копируйте целиком):

```python
# БЛОК 1: Исходные данные датчиков
sensor_probs = [0.7, 0.65, 0.8]           # надёжность каждого датчика
sensor_angles = [0.0, np.pi/6, np.pi/4]   # калибровочные сдвиги
print("Датчики:", [(p, f"угол={round(np.degrees(a))}°") for p, a in zip(sensor_probs, sensor_angles)])

# БЛОК 2: Моделируем реальные шумы
sensors = []
for p, angle in zip(sensor_probs, sensor_angles):
    s = PhaseState(p, angle)
    s = amp_damp(s, alpha=0.15)             # затухание сигнала
    s = dephase(s, sigma_phi=0.08)          # фазовый шум
    sensors.append(s)

print("После шума:", [round(s.probability, 3) for s in sensors])

# БЛОК 3: Слияние датчиков
set_phase_or_mode('weight')  # робастный режим
fused = sensors[0]
for sensor in sensors[1:]:
    fused = fused | sensor

print("Объединённый сигнал:", round(fused.probability, 4))

# БЛОК 4: Если много гипотез — используйте регистр
print("\nАнализ гипотез через регистр:")
reg = PhaseRegister.uniform(3)  # 2^3 = 8 гипотез
reg.apply_oracle(lambda x: int(x in [1, 3, 5]))  # отметим некоторые гипотезы
reg.hadamard_all()
best_hypothesis = reg.argmax_probability()
print("Лучшая гипотеза (индекс):", best_hypothesis)
print("Её вероятность:", round(reg.measure_probability(best_hypothesis), 4))
```

**Что менять под вашу задачу:**
- `sensor_probs` — доверие к каждому датчику
- `sensor_angles` — калибровочные поправки (если знаете)
- Параметры шума `alpha`, `sigma_phi` — по вашим измерениям
- В `apply_oracle` — логику выбора гипотез
---

## Кейс 3: A/B-тестирование

**Задача:** Сравнить варианты A и B, агрегировать сигналы от разных источников, понять достаточность данных.

### Рецепт (копируйте целиком):

```python
# БЛОК 1: Базовое сравнение A vs B
pA, pB = 0.12, 0.145  # ваши конверсии
print(f"Конверсия A: {pA}, конверсия B: {pB}")

# Информационные метрики
h_a = shannon_entropy(pA)
h_b = shannon_entropy(pB)
kl_ab = kl_divergence(pA, pB)
kl_ba = kl_divergence(pB, pA)

print(f"Неопределённость A: {round(h_a, 3)}, B: {round(h_b, 3)}")
print(f"Отличие A→B: {round(kl_ab, 3)}, B→A: {round(kl_ba, 3)}")

if max(kl_ab, kl_ba) < 0.01:
    print("⚠️  Различия слабые, нужно больше данных")
else:
    print("✅ Различия заметные")

# БЛОК 2: Агрегация множественных источников
# Например, разные каналы/сегменты дают разные оценки A и B
channels_A = [0.11, 0.13, 0.12, 0.14]  # оценки A от разных каналов
channels_B = [0.13, 0.15, 0.14, 0.16]  # оценки B от разных каналов

# Пометим согласованность каналов
# Скажем, первые два канала согласованы, остальные конфликтуют
angles_A = [0.0, 0.0, np.pi, np.pi/2]
angles_B = [0.0, 0.0, np.pi, np.pi/2]

def aggregate_channels(probs, angles, label):
    set_phase_or_mode('norm')  # консервативно для A/B
    states = [PhaseState(p, a) for p, a in zip(probs, angles)]
    result = states[0]
    for state in states[1:]:
        result = result | state
    print(f"Агрегированный {label}: {round(result.probability, 4)}")
    return result

agg_A = aggregate_channels(channels_A, angles_A, "A")
agg_B = aggregate_channels(channels_B, angles_B, "B")

# БЛОК 3: Устойчивость под шумом
print("\nПроверка устойчивости:")
for noise_level in [0.05, 0.15, 0.25]:
    a_noisy = dephase(agg_A, sigma_phi=noise_level)
    b_noisy = dephase(agg_B, sigma_phi=noise_level)
    diff = abs(a_noisy.probability - b_noisy.probability)
    print(f"Шум {noise_level}: разность A-B = {round(diff, 4)}")
```

**Что менять под вашу задачу:**
- `pA`, `pB` — ваши базовые конверсии
- `channels_A`, `channels_B` — оценки от разных источников
- `angles_A`, `angles_B` — согласованность источников (0 = вместе, π = против)
- Пороги для "слабых различий" в KL
---

## Быстрые советы по выбору режимов

**Режимы склейки (set_phase_or_mode):**
- `'weight'` — начните с этого, робастный компромисс
- `'norm'` — когда нужна гарантия p ∈ [0,1] при многих источниках
- `'quant'` — для исследований, показывает "потенциал усиления"
- `'opt'` — теоретическая согласованность уровней 3↔4

**Углы согласованности:**
- `0.0` — источники дублируют/усиливают друг друга
- `np.pi` — источники компенсируют/противоречат
- `np.pi/2` — частичный конфликт
- Если не уверены — начните с `0.0` и `np.pi`

**Параметры шума:**
- `sigma_phi=0.05-0.2` — фазовая нестабильность
- `alpha=0.1-0.3` — затухание амплитуды
- Больше значения = больше шума
---

## Что дальше

1. **Скопируйте нужный блок** под вашу задачу
2. **Подставьте свои числа** в помеченные места
3. **Проверьте результат** на вашем тестовом наборе
4. **Настройте углы и режим** по валидации
5. **Добавьте мониторинг** устойчивости к шуму

Если что-то не работает — сначала проверьте импорты и установку matplotlib, потом экспериментируйте с режимами и углами.
#### A/B‑анализ и принятие решений
Задача: оценить, насколько A отличается от B, и сколько данных нужно. Часто источников несколько (каналы, сегменты, модели), и их вклад противоречив.
Как делать:
1) На уровне 2 посчитайте H₂(p) — мера неопределённости варианта — и KL(pA||pB) (и наоборот) — насколько A не похоже на B. Если KL малая — отличия слабые, нужен больший объём.
2) При агрегировании многих источников, приводящих pA/pB, можно перейти на уровень 4 и отразить противоречия фазами: согласованные каналы — близкие φ, конфликтующие — φ≈π; режим ‘norm’/‘weight’ для безопасности.
3) Если различия нестабильны — добавьте шумы и проверьте, насколько меняется итог (устойчив ли вывод).
Что это даёт аналитику:
Базовая статистика (H₂, KL) + инструмент осмысленного объединения сигналов (⊕₄) при сложных контурах данных.
Уменьшение “переучёта” при дублях и прозрачная политика в конфликтных данных (когда одни каналы “за”, другие “против”).
### Как выбирать «углы согласованности» (фазы) и режим — практические подсказки
Если нет доменной экспертизы по фазам, начните с простого: φ=0 (согласие), φ=π (конфликт). Это уже даёт пользу: дубли не гиперусиливаются, контр‑сигналы компенсируются.
Постепенно уточняйте φ по валидации/метрикам (например, по стабильности итогового P под шумом или по точности на ретроспективе).
Режим ⊕₄:
Начальный продакшен — ‘weight’: как правило, даёт хорошее соотношение “усиливает согласованное, но не срывает крышу”.
Строгий контроль — ‘norm’: полезно при длинных пайплайнах/регуляторике.
Исследования — ‘quant’: увидеть потенциал “верхнего предела”.
Теоретическая согласованность 3↔4 — ‘opt’ (Δφ=π/2).
Особая логика? ‘custom’: впишите собственное правило сочетания p и φ.
### Проверка и верификация (чтобы не обмануть себя)
Держите рядом метрики: H₂/H₃/H₄ для итогового состояния, KL для сравнения сценариев, когерентность (L4).
Прогоняйте “шумовые прогоны” (σφ, α) — если вывод сильно меняется, либо переоценили согласованность, либо режим слишком агрессивен.
Смотрите потери информации при проекциях (4→3→2): вы явно видите, что теряется при упрощении — это полезно и для документации, и для аудита.
### Ограничения и честные оговорки
Это не универсальный квантовый симулятор; тензорная структура уровня 4 здесь приближённая, без полноценной запутанности и унитарных цепочек уровня QSDK.
Непрерывные энтропии считаются численно; точность зависит от сетки и параметров интегрирования.
Фазы — это модель. Их нужно выбирать осмысленно и проверять валидацией.
### С чего начать (быстрый план внедрения)
Спринт 1 (неделя):
Привести 3–5 источников в L2, получить базовый “p(any)” и H₂.
Добавить L4 для двух очевидных “дублей/контр‑сигналов”: φ=0/π, режим ‘weight’.
Сравнить результат и стабильность под σφ∈{0.05,0.2}, α∈{0.1,0.3}.
Спринт 2:
Точнее подобрать φ на ретроспективе, включить ещё 2–3 источника, где есть конфликт.
Добавить отчёт о потерях информации при проекциях (4→3→2), формально описать политику ⊕₄.
Спринт 3:
Если гипотез много — задействовать PhaseRegister для ускоренного перебора/оценки, добавить POVM‑критерий.
Закрепить практики: “когда ‘norm’/‘weight’/‘quant’”, чек‑лист по шумам, мониторинг когерентности.
### Итог
Библиотека полезна, потому что делает сложные вопросы слияния вероятностей управляемыми: есть фазы (согласованность), режимы ⊕₄ (политика), шумы (устойчивость), энтропии и KL (диагностика), и простые интерфейсы (L2→L3→L4).
Она “приземляет” абстрактные идеи интерференции к очень практичным задачам: риски, сенсоры, A/B — там, где нужно не только “сложить вероятности”, но и осмысленно учесть зависимость, дубли и конфликты.